[{"authors":["admin"],"categories":null,"content":"I am a Ph.D. Candidate in Computer Science \u0026amp; Engineering  at University of California Riverside(UCR), Where I work with Dr. Zhijia Zhao. My research spans the intersection of software engineering, programming languages, and mobile systems, I explore ideas from each and apply them on automatic detection, optimization, prevention, and mitigation of issues in software. I regularly publish in top conferences, including MobiSys, ASPLOS, and OOPSLA.\nMy research has been recognized with a Best Paper Runner-up Award @ MobiSys'18 and ACM SIGMOBILE Research Highlights (2018).\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"http://ufarooq.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a Ph.D. Candidate in Computer Science \u0026amp; Engineering  at University of California Riverside(UCR), Where I work with Dr. Zhijia Zhao. My research spans the intersection of software engineering, programming languages, and mobile systems, I explore ideas from each and apply them on automatic detection, optimization, prevention, and mitigation of issues in software. I regularly publish in top conferences, including MobiSys, ASPLOS, and OOPSLA.\nMy research has been recognized with a Best Paper Runner-up Award @ MobiSys'18 and ACM SIGMOBILE Research Highlights (2018).","tags":null,"title":"","type":"authors"},{"authors":["Umar Farooq","Zhijia Zhao","Manu Sridharan","Iulian Neamtiu"],"categories":[],"content":"","date":1601506700,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601506700,"objectID":"86734c4a56c3636f6b337ab116f987c1","permalink":"http://ufarooq.github.io/publication/oopsla20/","publishdate":"2020-09-30T15:58:20-07:00","relpermalink":"/publication/oopsla20/","section":"publication","summary":"Mobile operating systems, such as Android, expose apps to a volatile runtime environment. For example, app state that reflects past user interaction can be destroyed implicitly, in response to runtime changes (e.g., screen rotation) or high memory pressure. Developers are therefore responsible for identifying that app state affected by volatility and preserving it across app lifecycles. When handled inappropriately, the app may lose state or end up in an inconsistent state when users return to the app.\nTo free developers from this tedious and error-prone task, this work proposes a systematic solution -- LiveDroid, which automatically and precisely identifies the app state, saves it before the app gets destroyed, and recovers it when users return to the app. LiveDroid consists of: (i) a static analyzer that reasons about data uses to pinpoint the critical data set that capture the user interaction, and (ii) a runtime system that manages the data saving and recovering. We implemented LiveDroid as a plugin in Android Studio and a patching tool for APKs. Our evaluation shows that LiveDroid can be successfully applied to 966 Android apps. A focused study with 36 Android apps shows that LiveDroid identifies app state much more precisely than existing work. As a result, on average, LiveDroid is able to reduce the costs of state saving and restoring by 16.6X (1.7X - 141.1X) and 9.5X (1.1X - 43.8X), respectively. Furthermore, compared with the manual state handling performed by developers, our analysis reveals a set of 46 app state issues due to the incomplete state saving/restoring, all of which can be successfully eliminated by LiveDroid.","tags":[],"title":"LiveDroid: Identifying and Preserving Mobile App State in Volatile Runtime Environments","type":"publication"},{"authors":["Umar Farooq","Zhijia Zhao"],"categories":[],"content":"","date":1559430429,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1559430429,"objectID":"fdf5627d7ad3ab352185efe5a13927e0","permalink":"http://ufarooq.github.io/publication/getmobile/","publishdate":"2019-06-01T16:07:09-07:00","relpermalink":"/publication/getmobile/","section":"publication","summary":"Portable devices, like smartphones and tablets, are often subject to higher frequency of configuration changes, such as screen orientation changes, screen resizing, keyboard attachments, and language switching. Since the changes can happen at runtime while users interact with the devices, they are referred to as runtime changes. Recent studies have shown that runtime changes happen regularly as users operate their apps. For example, on average, users change the orientation of their devices every five minutes accumulatively over sessions of the same app [1]. For multilingual or tablet users, changing the language setting or attaching an external keyboard is often desired. As newer versions of Android systems with multiwindow supports are adopted, it is projected that runtime changes will happen more frequently. Each time a user drags the boundary between two split windows, a runtime change would be triggered.","tags":[],"title":"RuntimeDroid: Restarting-Free Runtime Change Handling for Android Apps","type":"publication"},{"authors":["Lin Jiang","Xiaofan Sun","Umar Farooq","Zhijia Zhao"],"categories":[],"content":"","date":1554159500,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554159500,"objectID":"1b8d7aff84b130d1a16feb44f19ecd7e","permalink":"http://ufarooq.github.io/publication/asplos19/","publishdate":"2019-04-01T15:58:20-07:00","relpermalink":"/publication/asplos19/","section":"publication","summary":"JSON (JavaScript Object Notation) and its derivatives are essential in the modern computing infrastructure. However, existing software often fails to process such types of data in a scalable way, mainly for two reasons: (i) the processing often requires to build a memory-consuming parse tree; (ii) there exist inherent dependences in processing the data stream, preventing any data-level parallelization. Facing the challenges, developers often have to construct ad-hoc pre-parsers to split the data stream in order to reduce the memory consumption and increase the data parallelism. However, this strategy requires more programming efforts. Moreover, the pre-parsing itself is non-trivial to parallelize, thus introducing a new serial bottleneck. To solve the dilemma, this work introduces a scalable yet fully automatic solution - a compilation system, namely JPStream, that compiles standard JSONPath queries into parallel executables with bounded memory footprints. First, JPStream adopts a stream processing design that combines the querying and parsing into one pass, without generating any in-memory parse tree. To achieve this, JPStream uses a novel joint compilation technique that compiles the queries and the JSON syntax together into a single automaton. Furthermore, JPStream leverages the _enumerability_ of automaton to break the dependences and reason about the transition rules to prune infeasible states. It also features a runtime that learns structural constraints from the input to enhance the pruning. Evaluation on real-world JSON datasets with standard JSONPath queries shows that JPStream can reduce the memory consumption significantly, by up to 95%, meanwhile achieving near-linear speedup on multicore and manycore processors.","tags":[],"title":"Scalable Processing of Contemporary Semi-Structured Data on Commodity Parallel Processors - A Compilation-based Approach","type":"publication"},{"authors":["Umar Farooq","Zhijia Zhao"],"categories":[],"content":"","date":1527892278,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1527892278,"objectID":"cf34462b668c993cab5cb9588ef11696","permalink":"http://ufarooq.github.io/publication/mobisys18/","publishdate":"2018-06-01T15:31:18-07:00","relpermalink":"/publication/mobisys18/","section":"publication","summary":"In Android systems, configuration changes, such as screen orientation changes, screen resizing, keyboard attachments, and language switching, are typically handled by application restarting, which, due to poor coding practices, can result in user data loss to app crashes. RuntimeDroid describe a restart-free runtime that avoids the need for application restarting while ensuring proper resource updating and user data preservation.","tags":[],"title":"RuntimeDroid: Restarting-Free Runtime Change Handling for Android Apps","type":"publication"}]